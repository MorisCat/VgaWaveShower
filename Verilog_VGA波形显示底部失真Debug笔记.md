# 显示的波形底部显示失真可能的原因

## 控制显示波形的因素有哪些？

### 图片有效区域

### `.coe`文件

### `if`中的判断条件

## 观察到的实验现象

### 失真区域随波形上下移动

可以知道与图片有效区域无关

### 更换多种`.coe`文件现象仍然存在

与.`coe`文件无关

## `if`中更换判断条件

尝试了更改移位的大小，以及减数的大小，无效

## 改波幅度

底部显示失真位置及大小不变

## 改`y`参数

没有具有参考价值的实验现象

## 没办法就跑仿真（找到原因与解决方法）

### 产生波形底部失真的原因就在if的判断里

1. 大体估算一下失真位置的坐标（我当时估算的挺准的`x:400 , y:360`）

2. 在仿真中依据估算的坐标位置找到从ROM里读出的最低点的值（`0x0000`），以找到的值为中心，会发现左右两边数据对称

3. 发现`out_data`有值，但是·`img_data`值为零（黑色），操纵i`mg_data`的语句块只有`frame_Ctrl`中的一个功能块，给他赋值的只有`if`语句，所以产生失真的原因肯定是判断条件不满足，把最低点的值（`0x0000`）代入判断条件，发现最低点周围的点确实不满足`if`的判断条件所以波形底部显示失真。

4. 接下来调整一下判断条件试一下

5. 上网搜索发现一条`Verilog`的特性，这个特性正好解释了为什么一直是一条宽度不能变的细线，因为

   ```C
   /*错误的代码*/
   else if(out_data <= ((350 - pos_y)<<8)  && out_data >= ((350 - pos_y)<<8) - 1000)
           img_data <= 16'hff0;
   ```

   

   `pos_y`一旦大于了被减数，左值就会变成负数，而在verilog中一个负数，一般情况下会被视为正数，所以判断为假，`pos_y`以下的值全部为假，所以最底部的波形会一直是一条细线，这条细线甚至会在左值减去一个较大的数如1000时消失

## 解决方法

目前有两个思路：

1. 加一个算法：如果是负数，就把这个数变成0
2. 对读出来的数据`out_data`做手脚，把读出来的数据在判断之前先加上一个数

## 注意

`Verilog`中一个负数，通常会被视为正数

## 正确的核心代码

```C
/*波形显示*/
always@(posedge vga_clk or posedge rst_p) begin
    if(rst_p)
        img_data <= 1'b0;
    else if(out_data <= ((350 - pos_y)<<8) + 900 && out_data >= ((350 - pos_y)<<8))
        img_data <= 16'hff0;
    else
        img_data <= 16'h000;
end
```

## 位宽问题

上述正确代码的`350`位宽指定的大一些，指定小了显示会出现显示区域内有多个波形的问题（初步猜测是溢出导致的）

## 位宽问题产生的真正原因

10位数据左移$n$位还是10位数据，左移只会截去高位数据而不会拓展数据的位宽，所以如果位宽指定过小，算式中的左移会截去高位，让数据变得很小，所以要给足位宽，让数据有充分的空间左移
